### 广义表还原为二叉树

> 具有完全包含关系，所以使用栈进行解决

> 对于字符二叉树来说， 入栈的有四种元素1 ：字符  2：左括号  3： 逗号 4：右括号

> 思路如下，首先是读入所有字符（除空格以外的），遇到左括号那么对应的就标记左孩子，遇到逗号就标记右孩子，遇到又括号则就返回到该节点的父节点（我们使用flag对节点进行标记，如果flag为0，则就标记左节点，flag为1 就标记右节点，值得注意的是对应的我们要有一个传入参数表示节点的数目记为node_num

1. 当遇到左括号的时候，下一步就需要处理左节点，此时将当前创建的节点入栈，作为栈顶元素
2. 遇到字符时，那么就创建一个节点对象作为根节点，判断对应的栈是否为空以及对应的标记是等不等于0，如果成立的话，就把当前节点赋值给栈顶元素的左孩子，同理如果标记flag为1，就把当前节点赋值给栈顶元素的左孩子，对应的节点数目加一
3. 如果遇到右括号，那么对应的操作就是返回父节点，并且相应的元素出栈
4. 重复以上的操作直到最终返回的是根节点

``` c
//广义表还原为二叉树
Node *build(char *str, int *node_num) {
	Node *temp = NULL, *p = NULL;//定义两个节点指针
	Stack *s = init_stack(strlen(str));//初始化一个栈来存储对应的广义表
	int flag = 0;//标记符号
	while (str[0]) {//当根节点一直存在时
		switch (str[0]) {
			case '('://判断遇到左括号的情况
				push(s,temp);//当前创捷的节点入栈
				flag = 0;//标记左孩子
				temp = NULL;
				break;
			case ')':
				p = top(s);//遇到右括号那么就会返回当前节点根节点
				pop(s);//栈顶元素出栈
				break;
			case ',':
				flag = 1;//遇到逗号则表示要标记右节点
				temp = NULL;
				break;
			case ' ':
				break;//对于输入的空格不做任何操作
			default://一下处理的就是对应栈的字符了
				temp = getNewNode(str[0]);
				if (!empty(s) && flag == 0) {
					top(s)->lchild = temp;//判断对应的栈是否为空以及对应的标记是等不等于0，如果成立的话，就把当前节点赋值给栈顶元素的左孩子
				} else if(!empty(s) && flag == 1) {
					top(s)->rchild = temp;	//如果标记flag为1，就把当前节点赋值给栈顶元素的左孩子，对应的节点数目加一			
				}
				++(*node_num);//对应的节点个数加一
			break;
		}
		str++;
	}
	clear_stack(s);//栈清空操作
	if (temp && !p) p = temp;
	return p;
}
```

