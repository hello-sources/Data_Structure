## 排序

> 排序可以分为稳定排序，非稳定排序（x轴）。以及内部排序，外部排序（y轴）

> 内部排序就是开辟的内存空间中进行排序，外部排序就是不一定完整的全都加载到内存空间中，这主要是考虑到系统内存空间大小问题

### 稳定排序

> 稳定排序就是对于大小相同的元素，相对位置是不同的，在经过排序之后，对应的相对位置不发生改变，这就是稳定排序

- 插入排序

> 1. 将数据分为已排序区和待排序区
> 2. 将已排序区后面一个元素向前插入到待排序区
> 3. 直到待排序区域没有元素
>
> 插入排序时间复杂度分析：O(n^2) 均摊时间复杂度
>
> 最好的情况就是一直是有序的，所以只是需要遍历所有的待排序序列就行了，最好的时间复杂度就是O(n).

``` c
//插入排序，已经排序数组在前，从前到后遍历，如果后面的小就交换位置 
void insert(int *num, int n) {
	for (int i = 1; i < n; i++) {
		for (int j = i; j > 0 && num[j] < num[j - 1]; j--) {
			swap(num[j], num[j - 1]);
		}
	}
	return ;
}
```



- 冒泡排序

> 与插入排序的区别就是对应的待排序区域在已排序区的前面

> 1. 将数组分为已排序区和待排序区域
> 2. 从头到尾扫描待排序区，如果前面元素比后面元素大，就交换
> 3. 每一轮就会将待排序区中最大的放到已排序区的开头
> 4. 直到待排序区没有元素为止
>
> 时间复杂度也是：O(n^2) 均摊时间复杂度

> 冒泡排序的优化：如果当前某一轮结束之后，没有发现元素进行交换的情况，你那么冒泡排序就直接结束了，在实际的程序编写的时候就需要加上一个标志位，flag初始化为0，然后下一轮的时候先进行判断标志位

``` c
//冒泡排序，已排序数组在后 
void bubble_sort(int *num, int n) {
	int times = 1;//初始标记位置为1 
	//优化方案使用标记位，来判断对应的数组是否已经满足顺序 
	for (int i = 1; i < n && times; i++) {
		times = 0;
		for (int j = 0; j < n - i; j++) {
			if (num[j] <= num[j + 1]) continue;//使用对偶逻辑来优化代码 
			swap(num[j], num[j + 1]);//如果后面的小于前面的数，就交换两个数的位置 
			times++;//更新对应的标记位 
		}
	}
	return ;
} 
```



- 归并排序

>简言之就是将两个有序的数组合并成为一个有序的数组，使用的是分治策略，将已有序列子序列合并，得到另外一个有序的序列，以此类推，直到整个序列都是有序的为止

> 我们可以尝试不断地将原问题转换为两个较小的问题，把原问题不停的进行分割成为子问题

> 归并排序时间复杂度分析：两个数组一个长度为M，一个长度为N，连个数组进行合并的时候时间复杂度就是O(M + N) ，，合并的时候时间复杂度为O(N)的，最好最优时间复杂度都稳定在O(NlogN)的水平上

> 二路归并排序就是每一次把一个序列分为两个部分，多路归并排序就是一次分成多个部分进行排序
>
> 当我们处理数据量比较大的数据分类的时候，由于电脑系统内存限制，我们需要把数据进行分别排序，然后再进行合并，因此归并排序又属于外部排序

``` c
//归并排序
void merge_sort(int *num, int l, int r) {
	if (r - l <= 1) {//首先判断对应数组元素大小如果小于两个数 
		if (r - l == 1 && num[l] > num[r]) {
			swap(num[l], num[r]);//交换；两个位置 
		}
		return ;//直接返回即可 
	}
	//二路归并，从中间开始 
	int mid = (l + r) >> 1; 
	merge_sort(num, l, mid);//递归循环左半部分 
	merge_sort(num, mid + 1, r);//分别对于两端进行排序
	int *temp = (int *)malloc(sizeof(int) * (r - l + 1));
	//我们定义两个变量分别从左右两个数组初始位置开始，合并两个元素 
	int p1 = l, p2 = mid + 1, k = 0;//k记录的是位置
	while (p1 <= mid || p2 <= r) {//哪一个数比较小就把较小的数赋值给暂时开辟的数组 
		if (p2 > r || (p1 <= mid && num[p1] <= num[p2])) {
			temp[k++] = num[p1++];
		} else {
			temp[k++] = num[p2++];
		}
	} 
	memcpy(num + l, temp, sizeof(int) * (r - l + 1));//把暂时存储的数据拷贝给原来的数组 
	free(temp);//释放暂时开辟的空间 
	return ;
} 
```



### 不稳定排序

> 不稳定排序就是对于大小相同的两个元素，相对位置是不同的，在经过排序之后，排序之后元素相对位置发生改变,所以称为不稳定排序

- 选择排序

> 简言之就是把最小的元素放在原来序列的后面（值得注意的是，在变换的过程中相应数的位置会发生改变）

> 1. 将数组分为已排序区和待排序区
> 2. 每一次将待排序区中选择一个最小的元素放到待排序区的尾部
> 3. 一直持续直到待排序区没有元素为止

> 时间复杂度: O(n^2)

``` c
//选择排序 
void select_sort(int *num, int n) {
	for (int i = 0; i < n - 1; i++) {
		int ind = i;//选择一个基准值下标 
		for (int j = i + 1; j < n; j++) {//下标向后进行遍历，
		//找到比当前下标值小的数，交换两个下标 
			if (num[ind] > num[j]) ind = j;
		}
		//一个循环下来，下标表示的是当前最小的元素，交换两个位置 
		if (i == ind)continue; 
		swap(num[i], num[ind]);
	}
	return ;
}
```



- 快速排序

> 快速排序就是选择一个基数，一般是第一个，我们使用两个指针，l, r,一个指向最左边，一个指向最右边，把比基准值小的元素向前放，把比基准值小的数，像后面移动，直到两个指针指向一个位置的时候，排序结束

> 时间复杂度：O(nlogn);时间复杂度不是稳定的，特别的是对于那些逆序的数组，快速排序的时间复杂度就会变成O(n^2)，就是跟选择排序差不多的。

``` c
//快速排序
//传入两个指针，一个指向数组头，一个指向尾 
void quick_sort(int *num, int l, int r) { 
	if (r < l) return ;
	int x = l, y = r, z = num[l];//定义一个基准值为数组开头 
	while (x < y) {//左右指针不指向一个位置的时候继续循环 
		//对应尾部指针向前移动，找到比基准值小的元素下标 
		while (x < y && num[y] >= z) y--;
		if (x < y) num[x++] = num[y];//放在 
		//对应头部指针向后移动，找到比基准值大的元素下标 
		while (x < y && num[x] <= z) x++;
		if (x < y) num[y--] = num[x];
	} 
	num[x] = z;
	quick_sort(num, l ,x - 1);//对于左半部分进行快速排序 
	quick_sort(num, x + 1, r);//对于右半部分进行快速排序 
	return ;
} 
```



### 其他

- 宏定义交换函数

> 正常情况下我们可以使用以下两种方法来实现交换两个数的值

1. 使用抑或来交换函数

``` c
//可以使用抑或实现交换函数，
//抑或对于两个数值相同但是地址不同的可以实现交换
//但是对于相同地址的不可以进行交换，相同地址抑或的结果为0
#define swap(a, b) {\
	a ^= b; b ^= a; a ^= b;\
}
```

2. 使用中间变量实现交换函数

``` c
//宏定义交换函数，可以区别数据类型
//我们先定义一个与a类型相同的中间变量，先把a赋值给中间变量，然后b赋值给a,然后把中间变量赋值给b，就完成了交换函数
#define swap(a, b) {\
	__typeof(a) __temp = a;\
	a = b; b = __temp;\
}
```



- 定义一个宏，测试每一个排序函数

> 宏定义中由于我们实现的是排序函数，所以我们需要传入数组，存储待排序数，函数名称，以及函数所需要的参数，由于不同函数传入参数不及相同，所以我们使用变参函数来实际参数的传入

> 首先我们动态开辟一个暂时数组，然后把传入数组拷贝暂时数组，然后执行相关的函数，并且打印排序后的数组，最后释放暂时数组的空间

``` c
//宏定义来实现不同排序算法整合进行输出
//我们使用的是变参函数args来表示不同排序算法传入的参数
//在结束函数的时候，要释放相应空间 
#define TEST(arr, n, func, args...) {\
	int *num = (int *)malloc(sizeof(int) * n);\
	memcpy(num, arr, sizeof(int) * n);\
	output(num, n);\
	printf("%s = ", #func);\
	func(args);\
	output(num, n);\
	free(num);\
}

//函数调用时候直接按照一下方法调用即可
TEST(arr, max_op, insert, num, max_op);//插入排序 
TEST(arr, max_op, bubble_sort, num, max_op);//冒泡排序 
```

