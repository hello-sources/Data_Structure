### 糖果传递

#### 题目描述

 有n个小朋友坐成一圈，每人有 ai 个糖果。每人只能给左右两人传递糖果。每人每次传递一个糖果代价为 1。求使所有人获得均等糖果的最小代价。

------

#### 输入

 第一行一个正整数 n，表示小朋友的个数。（1≤n≤1,000,000）

 接下来 n 行，每行一个整数 ai，表示第 i 个小朋友得到的糖果的颗数。

#### 输出

 输出使所有人获得均等糖果的最小代价。

------

#### 样例输入

```
4
1
2
5
4
```

#### 样例输出

```
4
```

------

#### 数据规模与约定

 时间限制：1 s

 内存限制：256 M

 100% 的数据保证 1≤n≤1,000,000,0≤ai≤10,000,000

- **解题思路**

> 利用前缀和数组，每一个都需要传递减去对应位置乘以C个糖果，C对应的就是平均值，这样就可以把每一个数字调整为平均值的办法，这是不成环的现象，对于成环的
>
> 对于成环问题，我们需要知到的是对于成环情况下肯定有两个点是没有糖果交换的，就是尽可能给一个点，这样我们就把环砍开了，成为一个一维的不成环的序列，同样要用到前缀和数组，再利用前缀和序列减去对应均分糖果数
>
> Gi = Si - i * c, S就是对应的前缀和得到的结果累加和就是对应的糖果的最小代价 



- **解题代码**

```c++
#include <iostream>
#include <algorithm> 
#include <cmath>
using namespace std;
#define MAX_N 1000000
long long a[MAX_N + 5];
long long s[MAX_N + 5];
long long g[MAX_N + 5];
long long n, sum = 0, c, ans = 0;

int main() {
	cin >> n;
	for (long long i = 1; i <= n; i++) {
		cin >> a[i];
		s[i] = s[i - 1] + a[i];
		sum += a[i];  
	}
	c = sum / n;
	for (long long i = 1; i <= n; i++) {
		g[i] = s[i] - i * c;
	}
	sort(g + 1, g + 1 + n);
	c = g[n / 2];
	for (long long i = 1; i <= n; i++) {
		ans += abs(g[i] - c);
	}
	cout << ans << endl;
	return 0;
}
```

